<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Аналитика трудозатрат — парсинг Excel, дашборды, текстовый отчёт</title>
<style>
  :root{
    --gap: 12px;
    --pad: 10px;
    --border: 1px solid #d9d9d9;
    --radius: 10px;
    --bg: #fafafa;
    --muted:#6b7280;
    --accent:#1f6feb;
    --table-h: 540px; /* фиксированная высота окна с исходными данными */
  }
  html,body{margin:0;padding:0;background:#fff;color:#111;font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;}
  .container{max-width:1280px;margin:0 auto;padding:16px;}
  h1{margin:0 0 12px 0;font-size:20px;}
  .row{display:grid;grid-template-columns: 420px 1fr; gap: var(--gap);}
  .card{background:#fff;border:var(--border);border-radius:var(--radius);box-shadow:0 1px 2px rgba(0,0,0,.04);}
  .card h3{margin:0;padding:10px 12px;border-bottom:var(--border);font-size:14px;background:var(--bg);}
  .card .body{padding:12px;}
  .stack > * + *{margin-top:10px;}
  label{display:block;font-weight:600;margin-bottom:6px;}
  input[type="file"], select, input[type="date"]{
    width:100%;padding:8px 10px;border:var(--border);border-radius:8px;background:#fff;
  }
  .two{display:grid;grid-template-columns: 1fr 1fr; gap: var(--gap);}
  .filters .row1{display:grid;grid-template-columns: 1fr 1fr 1fr; gap: var(--gap);}
  .muted{color:var(--muted);}
  .btn{display:inline-block;border:var(--border);background:#fff;padding:8px 10px;border-radius:8px;cursor:pointer;user-select:none}
  .btn.primary{background:var(--accent);color:#fff;border-color:var(--accent)}
  .btn-row{display:flex;gap:8px;flex-wrap:wrap}
  .help{font-size:12px;color:var(--muted)}
  table{border-collapse:collapse;width:100%;font-size:13px}
  th,td{border:var(--border);padding:6px 8px;vertical-align:top}
  th{background:#f5f7fb;white-space:nowrap;position:sticky;top:0;z-index:1}
  .table-wrap{height:var(--table-h);overflow:auto;border:var(--border);border-radius:8px}
  .kpi{display:grid;grid-template-columns: repeat(4,1fr); gap: var(--gap); margin-top:var(--gap)}
  .kpi .box{border:var(--border);border-radius:8px;padding:10px;background:#fff}
  .kpi .box .v{font-size:18px;font-weight:700}
  .dash-grid{display:grid;grid-template-columns: repeat(3, 1fr); gap: var(--gap); margin-top:var(--gap)}
  .viz{border:var(--border);border-radius:10px;background:#fff}
  .viz .head{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;border-bottom:var(--border);background:#f9fafb}
  .viz .head .title{font-weight:600}
  .viz .body{padding:10px}
  .svg-wrap{width:100%;height:300px;overflow:auto}
  .legend{font-size:12px;color:var(--muted)}
  /* подпись внутри столбика в белом «квадратике», с отступом от оси */
  .bar-label{paint-order:stroke;stroke:#ffffff;stroke-width:6px}
  .tooltip{position:fixed;pointer-events:none;visibility:hidden;background:#111;color:#fff;padding:6px 8px;border-radius:6px;font-size:12px;z-index:50}
  /* отчёт */
  .report{margin-top:18px}
  #reportText{white-space:pre-wrap;border:var(--border);border-radius:8px;padding:12px;background:#fff;min-height:160px}
  .hr{height:1px;background:#eee;margin:12px 0}
  .sticky-note{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div class="container">
  <h1>Аналитика трудозатрат (Excel → дашборды → текстовый отчёт)</h1>

  <div class="row">
    <!-- ЛЕВАЯ КОЛОНКА -->
    <div class="stack">
      <div class="card">
        <h3>Загрузка файла</h3>
        <div class="body stack">
          <input id="file" type="file" accept=".xlsx,.xls" />
          <div class="two">
            <button id="btnClear" class="btn">Очистить</button>
            <div class="help">Поддерживается Excel. Файл читается локально в браузере.</div>
          </div>
        </div>
      </div>

      <div class="card">
        <h3>Выбор листа</h3>
        <div class="body stack">
          <select id="sheet"></select>
          <div class="help">Если книга содержит несколько листов — выберите нужный.</div>
        </div>
      </div>

      <div class="card">
        <h3>Диапазон дат и фильтры</h3>
        <div class="body stack filters">
          <div class="two">
            <div>
              <label>С даты</label>
              <input type="date" id="from"/>
            </div>
            <div>
              <label>По дату</label>
              <input type="date" id="to"/>
            </div>
          </div>
          <div class="row1">
            <div>
              <label>Проект</label>
              <select id="project"></select>
            </div>
            <div>
              <label>Вид работ</label>
              <select id="type"></select>
            </div>
            <div>
              <label>Исполнитель</label>
              <select id="person"></select>
            </div>
          </div>
          <div class="btn-row">
            <button id="btnApply" class="btn primary">Применить фильтры</button>
            <button id="btnReset" class="btn">Сбросить</button>
          </div>
          <div class="help">Списки фильтров взаимосвязаны и показывают только релевантные значения.</div>
        </div>
      </div>
    </div>

    <!-- ПРАВАЯ КОЛОНКА (исходная таблица фиксированной высоты) -->
    <div class="card">
      <h3>Исходные данные (с учётом текущих фильтров)</h3>
      <div class="body">
        <div id="srcInfo" class="sticky-note muted"></div>
        <div class="table-wrap">
          <table id="srcTable"></table>
        </div>
      </div>
    </div>
  </div>

  <!-- KPI -->
  <div class="kpi" id="kpiRow" style="display:none">
    <div class="box"><div class="t muted">Всего часов</div><div id="kpiHours" class="v">—</div></div>
    <div class="box"><div class="t muted">Проектов</div><div id="kpiProj" class="v">—</div></div>
    <div class="box"><div class="t muted">Исполнителей</div><div id="kpiPeople" class="v">—</div></div>
    <div class="box"><div class="t muted">Видов работ</div><div id="kpiTypes" class="v">—</div></div>
  </div>

  <!-- ДАШБОРДЫ -->
  <div class="dash-grid" id="dashGrid" style="display:none">
    <div class="viz">
      <div class="head"><div class="title" id="t1">Часы по проектам (Top-10)</div><div class="legend" id="l1"></div></div>
      <div class="body"><div class="svg-wrap"><svg id="svgProj" width="1000" height="300"></svg></div></div>
    </div>
    <div class="viz">
      <div class="head"><div class="title" id="t2">Часы по исполнителям (Top-10)</div><div class="legend" id="l2"></div></div>
      <div class="body"><div class="svg-wrap"><svg id="svgPers" width="1000" height="300"></svg></div></div>
    </div>
    <div class="viz">
      <div class="head"><div class="title" id="t3">Часы по видам работ (Top-10)</div><div class="legend" id="l3"></div></div>
      <div class="body"><div class="svg-wrap"><svg id="svgType" width="1000" height="300"></svg></div></div>
    </div>
    <div class="viz" style="grid-column:1 / -1">
      <div class="head"><div class="title" id="t4">Динамика по дням</div><div class="legend" id="l4"></div></div>
      <div class="body"><div class="svg-wrap"><svg id="svgDaily" width="1400" height="280"></svg></div></div>
    </div>
  </div>

  <!-- ТЕКСТОВЫЙ ОТЧЁТ -->
  <div class="report">
    <h3>Текстовый отчёт по текущей выборке</h3>
    <div class="btn-row" style="margin-bottom:8px">
      <button id="btnCopy" class="btn">Копировать</button>
      <button id="btnTxt" class="btn">Экспорт .txt</button>
    </div>
    <div id="reportText"></div>
  </div>
</div>

<div id="tooltip" class="tooltip"></div>

<!-- ЛОКАЛЬНЫЕ БИБЛИОТЕКИ -->
<script src="xlsx.full.min.js"></script>
<script src="arquero.min.js"></script>
<script src="dayjs.min.js"></script>

<script>
/* ========= ГЛОБАЛЬНОЕ СОСТОЯНИЕ ========= */
const el = {
  file:    document.getElementById('file'),
  clear:   document.getElementById('btnClear'),
  sheet:   document.getElementById('sheet'),
  from:    document.getElementById('from'),
  to:      document.getElementById('to'),
  project: document.getElementById('project'),
  type:    document.getElementById('type'),
  person:  document.getElementById('person'),
  apply:   document.getElementById('btnApply'),
  reset:   document.getElementById('btnReset'),
  srcInfo: document.getElementById('srcInfo'),
  srcTable:document.getElementById('srcTable'),
  kpiRow:  document.getElementById('kpiRow'),
  kpiHours:document.getElementById('kpiHours'),
  kpiProj: document.getElementById('kpiProj'),
  kpiPeople:document.getElementById('kpiPeople'),
  kpiTypes:document.getElementById('kpiTypes'),
  dash:    document.getElementById('dashGrid'),
  svgProj: document.getElementById('svgProj'),
  svgPers: document.getElementById('svgPers'),
  svgType: document.getElementById('svgType'),
  svgDaily:document.getElementById('svgDaily'),
  t1: document.getElementById('t1'), l1: document.getElementById('l1'),
  t2: document.getElementById('t2'), l2: document.getElementById('l2'),
  t3: document.getElementById('t3'), l3: document.getElementById('l3'),
  t4: document.getElementById('t4'), l4: document.getElementById('l4'),
  reportText: document.getElementById('reportText'),
  copy: document.getElementById('btnCopy'),
  txt:  document.getElementById('btnTxt'),
  tip:  document.getElementById('tooltip')
};
const S = {
  raw: [],        // все строки листа (после нормализации)
  filtered: [],   // отфильтрованные строки по UI
  wb: null,
  sheets: []
};

/* ========= УТИЛИТЫ ========= */
function normHeader(s){
  if (!s) return "";
  const x = String(s).trim().toLowerCase();
  return x.replace(/\s+/g,' ');
}
function pickColName(obj, candidates){
  const keys = Object.keys(obj||{});
  const map = {};
  keys.forEach(k=> map[normHeader(k)] = k);
  for (const c of candidates){
    if (map[c]) return map[c];
  }
  return null;
}
function parseDateMaybe(v){
  if (!v && v!==0) return null;
  // Excel даты
  if (typeof v === 'number') {
    try{
      const d = XLSX.SSF.parse_date_code(v);
      if (!d) return null;
      const iso = dayjs(new Date(Date.UTC(d.y, d.m-1, d.d))).format('YYYY-MM-DD');
      return iso;
    }catch(_){/* noop */}
  }
  // строки
  const s = String(v).trim();
  if (!s) return null;
  const tryFormats = ['YYYY-MM-DD','DD.MM.YYYY','D.M.YYYY','YYYY/MM/DD','DD/MM/YYYY','DD-MM-YYYY','YYYY.MM.DD'];
  for (const f of tryFormats){
    const d = dayjs(s, f, true);
    if (d.isValid()) return d.format('YYYY-MM-DD');
  }
  const d2 = dayjs(s);
  return d2.isValid() ? d2.format('YYYY-MM-DD') : null;
}
function toNumber(v){
  if (typeof v === 'number') return v;
  const s = String(v||'').replace(',', '.').replace(/\s/g,'').trim();
  const n = parseFloat(s);
  return Number.isFinite(n) ? n : 0;
}
function uniq(arr){ return Array.from(new Set(arr)); }
function contextLabel(){
  const a=[];
  if (el.project.value && el.project.value!=='*') a.push('Проект: ' + labelByKey('project', el.project.value));
  if (el.type.value && el.type.value!=='*') a.push('Вид работ: ' + labelByKey('type', el.type.value));
  if (el.person.value && el.person.value!=='*') a.push('Исполнитель: ' + labelByKey('person', el.person.value));
  if (el.from.value || el.to.value) a.push(`Период: ${el.from.value||'—'} — ${el.to.value||'—'}`);
  return a.join(' · ');
}
function labelByKey(kind, key){
  if (key==='*') return 'все';
  const list = {
    project: S.filtered.concat(S.raw).map(r=>r.projectDisp && r.projectKey? {k:r.projectKey, v:r.projectDisp}: null),
    type:    S.filtered.concat(S.raw).map(r=>r.typeDisp    && r.typeKey   ? {k:r.typeKey,    v:r.typeDisp}: null),
    person:  S.filtered.concat(S.raw).map(r=>r.personDisp  && r.personKey  ? {k:r.personKey,  v:r.personDisp}: null)
  }[kind].filter(Boolean);
  const m = new Map(list.map(o=>[o.k,o.v]));
  return m.get(key) || '(не задано)';
}

/* ====== ВСПОМОГАТЕЛЬНЫЕ ДЛЯ ОТЧЁТА (добавлено/обновлено) ====== */
function fmtPct(v){ return Number.isFinite(v) ? (v*100).toFixed(1) + "%" : "0.0%"; }
function safeSum(arr, f){ let s=0; for (const x of arr) s += f? (f(x)||0):(x||0); return s; }
function listBlock(arr,total){
  if (!arr || !arr.length) return "—";
  const sum = total>0 ? total : safeSum(arr, r=>r.h||r.value||0) || 1;
  return arr.map((r,i)=>{
    const label = r.projectDisp ?? r.personDisp ?? r.typeDisp ?? r.label ?? r.date ?? "(не задано)";
    const h = (r.h ?? r.value ?? 0);
    const share = h/sum;
    return `${String(i+1).padStart(2,"0")}. ${label}: ${h.toFixed(2)} ч (${(share*100).toFixed(1)}%)`;
  }).join("\n");
}
function buildDailySeries(table){
  const t = aq.from(table).filter(aq.escape(d=>d.date && d.date!=="(нет даты)"));
  const objs = t.groupby("date").rollup({h:d=>aq.op.sum(d.hours)}).orderby("date").objects();
  if (!objs.length) return [];
  const minD = dayjs(objs[0].date);
  const maxD = dayjs(objs[objs.length-1].date);
  const map = new Map(objs.map(o=>[o.date, o.h]));
  const res = [];
  for (let d=minD; d.isBefore(maxD)||d.isSame(maxD,"day"); d=d.add(1,"day")){
    const iso = d.format("YYYY-MM-DD");
    res.push({date: iso, h: Number(map.get(iso)||0)});
  }
  return res;
}
function movingAvg(arr, w){
  const out = Array(arr.length).fill(0);
  let sum = 0;
  for (let i=0;i<arr.length;i++){
    sum += arr[i];
    if (i>=w) sum -= arr[i-w];
    out[i] = i>=w-1 ? sum/w : NaN;
  }
  return out;
}
function stddev(arr){
  const v = arr.filter(Number.isFinite);
  if (!v.length) return 0;
  const m = v.reduce((a,b)=>a+b,0)/v.length;
  const s2 = v.reduce((a,b)=>a+(b-m)*(b-m),0)/v.length;
  return Math.sqrt(s2);
}
function detectAnomalies(series, w=7, k=1.5, kPct=1.3){
  if (series.length < w+2) return [];
  const vals = series.map(p=>p.h);
  const res = [];
  for (let i=w;i<vals.length;i++){
    const window = vals.slice(i-w, i);
    const mu = window.reduce((a,b)=>a+b,0)/w;
    const sd = stddev(window);
    const thr1 = mu + k*sd;
    const thr2 = mu * kPct;
    if (vals[i] > Math.max(thr1, thr2) && vals[i]>0){
      res.push({date: series[i].date, h: vals[i], mu, sd});
    }
  }
  return res;
}
function detectQuietZones(series, minLen=3){
  if (!series.length) return [];
  const zones = [];
  let runStart = null, runLen = 0;
  for (let i=0;i<series.length;i++){
    if ((series[i].h||0)===0){
      if (runStart==null) runStart = i;
      runLen++;
    } else {
      if (runLen>=minLen) zones.push({from: series[runStart].date, to: series[i-1].date, len: runLen});
      runStart = null; runLen = 0;
    }
  }
  if (runLen>=minLen) zones.push({from: series[runStart].date, to: series[series.length-1].date, len: runLen});
  return zones;
}
function imbalanceInfo(groups, topN=3, threshold=0.60){
  const sorted = [...groups].sort((a,b)=>(b.h??b.value??0)-(a.h??a.value??0));
  const total = safeSum(sorted, r=>r.h??r.value??0);
  const top = sorted.slice(0, topN);
  const topSum = safeSum(top, r=>r.h??r.value??0);
  const share = total>0 ? topSum/total : 0;
  return {trigger: share>=threshold, share, total, top};
}
function linearTrend(series){
  const n = series.length;
  if (n<8) return {ok:false};
  const xs = Array.from({length:n}, (_,i)=>i+1);
  const ys = series.map(p=>p.h);
  const meanX = xs.reduce((a,b)=>a+b,0)/n;
  const meanY = ys.reduce((a,b)=>a+b,0)/n;
  let num=0, den=0;
  for (let i=0;i<n;i++){ num += (xs[i]-meanX)*(ys[i]-meanY); den += (xs[i]-meanX)*(xs[i]-meanX); }
  const slope = den===0 ? 0 : num/den;
  const firstAvg = ys.slice(0, Math.max(3, Math.floor(n/4))).reduce((a,b)=>a+b,0)/Math.max(1, Math.max(3, Math.floor(n/4)));
  const lastAvg  = ys.slice(n-Math.max(3, Math.floor(n/4))).reduce((a,b)=>a+b,0)/Math.max(1, Math.max(3, Math.floor(n/4)));
  const change = firstAvg>0 ? (lastAvg-firstAvg)/firstAvg : (lastAvg>0?1:0);
  return {ok:true, slope, change};
}

/* ========= ПАРСИНГ EXCEL ========= */
el.file.addEventListener('change', async (e)=>{
  if (!e.target.files || !e.target.files[0]) return;
  const buf = await e.target.files[0].arrayBuffer();
  S.wb = XLSX.read(buf, {type:'array', cellDates:false, cellNF:false, cellText:false});
  S.sheets = S.wb.SheetNames.slice();
  // заполнить селект листов
  el.sheet.innerHTML = '';
  for (const s of S.sheets){
    const opt = document.createElement('option');
    opt.value = s; opt.textContent = s;
    el.sheet.appendChild(opt);
  }
  // авто-выбор: если есть «Работы», выберем его, иначе первый
  const idx = Math.max(0, S.sheets.findIndex(n=>/^работ/i.test(n)));
  el.sheet.selectedIndex = idx;
  loadSelectedSheet();
});

el.sheet.addEventListener('change', loadSelectedSheet);

function loadSelectedSheet(){
  if (!S.wb) return;
  const name = el.sheet.value || S.wb.SheetNames[0];
  const ws = S.wb.Sheets[name];
  const json = XLSX.utils.sheet_to_json(ws, {defval:null, raw:true});
  if (!json.length){
    S.raw = []; S.filtered = [];
    renderAll();
    return;
  }
  // распознаём колонки по содержимому заголовков (гибко)
  const sample = json[0];
  const dateCol   = pickColName(sample, ['дата','date','день','число']);
  const hoursCol  = pickColName(sample, ['часы','нормо-часы','нормочасы','часов','hours','duration']);
  const projCol   = pickColName(sample, ['проект','проект/портфель','project','portfolio']);
  const typeCol   = pickColName(sample, ['вид работ','работа','тип работ','work type','type']);
  const persCol   = pickColName(sample, ['исполнитель','сотрудник','фио','worker','employee','person','ответственный']);

  S.raw = json.map((row, i)=>{
    const d  = parseDateMaybe(dateCol ? row[dateCol] : null);
    const h  = toNumber(hoursCol ? row[hoursCol] : 0);
    const pr = String(projCol && row[projCol] != null ? row[projCol] : '').trim();
    const tp = String(typeCol && row[typeCol] != null ? row[typeCol] : '').trim();
    const pe = String(persCol && row[persCol] != null ? row[persCol] : '').trim();
    return {
      _row:i+2,
      date: d || '(нет даты)',
      hours: h,
      project: pr || '',
      type: tp || '',
      person: pe || '',
      projectKey: pr.toLowerCase() || '(не задано)',
      typeKey: tp.toLowerCase()    || '(не задано)',
      personKey: pe.toLowerCase()  || '(не задано)',
      projectDisp: pr || '(не задано)',
      typeDisp: tp || '(не задано)',
      personDisp: pe || '(не задано)'
    };
  });

  // авто-диапазон дат
  const dates = S.raw.map(r=>r.date).filter(x=>x && x!=='(нет даты)');
  if (dates.length){
    const min = dates.slice().sort()[0];
    const max = dates.slice().sort().reverse()[0];
    el.from.value = min;
    el.to.value   = max;
  } else {
    el.from.value = ''; el.to.value = '';
  }

  // инициализация фильтров
  fillFilters();
  applyFilters();
}

/* ========= ФИЛЬТРЫ ========= */
function fillFilters(){
  const all = S.raw;
  const set = (sel, arr, withAll=true)=>{
    const old = sel.value;
    sel.innerHTML = '';
    if (withAll){
      const opt = document.createElement('option'); opt.value='*'; opt.textContent='— Все —'; sel.appendChild(opt);
    }
    arr.forEach(v=>{
      const opt = document.createElement('option'); opt.value=v.key; opt.textContent=v.disp; sel.appendChild(opt);
    });
    // восстанавливаем выбор если можно
    if ([...sel.options].some(o=>o.value===old)) sel.value = old;
  };
  // без ограничений
  const projects = uniq(all.map(r=>r.projectKey)).filter(Boolean).sort().map(k=>{
    const disp = (all.find(r=>r.projectKey===k)||{}).projectDisp || '(не задано)'; return {key:k, disp};
  });
  const types = uniq(all.map(r=>r.typeKey)).filter(Boolean).sort().map(k=>{
    const disp = (all.find(r=>r.typeKey===k)||{}).typeDisp || '(не задано)'; return {key:k, disp};
  });
  const people = uniq(all.map(r=>r.personKey)).filter(Boolean).sort().map(k=>{
    const disp = (all.find(r=>r.personKey===k)||{}).personDisp || '(не задано)'; return {key:k, disp};
  });
  set(el.project, projects);
  set(el.type, types);
  set(el.person, people);
}

function depopulateFilters(base){
  // пересчёт значений по выбранным зависимостям
  const projKey = el.project.value, typeKey = el.type.value, personKey = el.person.value;
  const pass = (r)=>{
    if (projKey!=='*'   && r.projectKey!==projKey) return false;
    if (typeKey!=='*'   && r.typeKey!==typeKey) return false;
    if (personKey!=='*' && r.personKey!==personKey) return false;
    return true;
  };
  const pool = base.filter(pass);
  const set = (sel, arr)=>{
    const cur = sel.value;
    sel.innerHTML = '';
    const opt = document.createElement('option'); opt.value='*'; opt.textContent='— Все —'; sel.appendChild(opt);
    arr.forEach(v=>{
      const opt2 = document.createElement('option'); opt2.value=v.key; opt2.textContent=v.disp; sel.appendChild(opt2);
    });
    if ([...sel.options].some(o=>o.value===cur)) sel.value = cur;
  };
  const projects = uniq(pool.map(r=>r.projectKey)).filter(Boolean).sort().map(k=>{
    const disp = (pool.find(r=>r.projectKey===k)||{}).projectDisp || '(не задано)'; return {key:k, disp};
  });
  const types = uniq(pool.map(r=>r.typeKey)).filter(Boolean).sort().map(k=>{
    const disp = (pool.find(r=>r.typeKey===k)||{}).typeDisp || '(не задано)'; return {key:k, disp};
  });
  const people = uniq(pool.map(r=>r.personKey)).filter(Boolean).sort().map(k=>{
    const disp = (pool.find(r=>r.personKey===k)||{}).personDisp || '(не задано)'; return {key:k, disp};
  });
  set(el.project, projects);
  set(el.type, types);
  set(el.person, people);
}

function applyFilters(){
  if (!S.raw.length){
    S.filtered = [];
    renderAll();
    return;
  }
  const f = el.from.value, t = el.to.value;
  const projKey = el.project.value, typeKey = el.type.value, personKey = el.person.value;
  S.filtered = S.raw.filter(r=>{
    if (f && r.date && r.date!=='(нет даты)' && r.date < f) return false;
    if (t && r.date && r.date!=='(нет даты)' && r.date > t) return false;
    if (projKey!=='*'   && r.projectKey!==projKey) return false;
    if (typeKey!=='*'   && r.typeKey!==typeKey) return false;
    if (personKey!=='*' && r.personKey!==personKey) return false;
    return true;
  });
  // взаимозависимые списки — на основе всех данных, но с учётом уже выбранных
  depopulateFilters(S.raw);
  renderAll();
}

/* ========= ОТРИСОВКА ========= */
function renderAll(){
  renderSourceTable();
  renderKPI();
  renderCharts();
  renderReport();
}

function renderSourceTable(){
  const rows = S.filtered;
  el.srcInfo.textContent = rows.length ? `Строк: ${rows.length}` : 'Нет данных для отображения.';
  const cols = ['date','projectDisp','typeDisp','personDisp','hours'];
  const names= ['Дата','Проект','Вид работ','Исполнитель','Часы'];
  const thead = `<thead><tr>${names.map(n=>`<th>${n}</th>`).join('')}</tr></thead>`;
  const tbody = `<tbody>${
    rows.slice(0,5000).map(r=>{
      const vals = [r.date, r.projectDisp||'(не задано)', r.typeDisp||'(не задано)', r.personDisp||'(не задано)', (r.hours||0).toFixed(2)];
      return `<tr>${vals.map(v=>`<td>${String(v)}</td>`).join('')}</tr>`;
    }).join('')
  }</tbody>`;
  el.srcTable.innerHTML = thead + tbody;
}

function renderKPI(){
  const t = aq.from(S.filtered);
  const total = (t.rollup({h:d=>aq.op.sum(d.hours)}).objects()[0]||{h:0}).h||0;
  const projs = uniq(S.filtered.map(r=>r.projectKey)).filter(Boolean);
  const people= uniq(S.filtered.map(r=>r.personKey)).filter(Boolean);
  const types = uniq(S.filtered.map(r=>r.typeKey)).filter(Boolean);
  el.kpiHours.textContent = total.toFixed(2);
  el.kpiProj.textContent  = projs.length;
  el.kpiPeople.textContent= people.length;
  el.kpiTypes.textContent = types.length;
  el.kpiRow.style.display = S.filtered.length ? '' : 'none';
}

function maxOf(arr, acc){ let m=0; for (const x of arr){ const v=acc?acc(x):x; if (v>m) m=v; } return m; }
function drawBars(svg, data, opt){
  // opt: {cat,label, val, w, h, padX, padY, color}
  const NS="http://www.w3.org/2000/svg";
  while (svg.firstChild) svg.removeChild(svg.firstChild);
  const w = opt.w||1000, h=opt.h||300, padX=opt.padX||80, padY=opt.padY||28;
  svg.setAttribute('width', w); svg.setAttribute('height', h);
  const innerW = w - padX - 20, innerH = h - padY - 20;
  const max = Math.max(1, maxOf(data, d=>d[opt.val]));
  const bw = Math.max(16, Math.floor(innerW / data.length) - 6);
  // оси
  const axis = document.createElementNS(NS,'line');
  axis.setAttribute('x1', padX); axis.setAttribute('y1', h-20);
  axis.setAttribute('x2', w-10); axis.setAttribute('y2', h-20);
  axis.setAttribute('stroke', '#cbd5e1'); axis.setAttribute('stroke-width','1');
  svg.appendChild(axis);

  // bars
  data.forEach((d,i)=>{
    const x = padX + i*(bw+6);
    const barH = Math.round((d[opt.val]/max) * (innerH-10));
    const y = (h-20) - barH;
    // прямоугольник
    const rect = document.createElementNS(NS,'rect');
    rect.setAttribute('x', x);
    rect.setAttribute('y', y);
    rect.setAttribute('width', bw);
    rect.setAttribute('height', barH);
    rect.setAttribute('fill', opt.color || '#1f6feb');
    rect.setAttribute('rx','3');
    rect.setAttribute('data-tip', (d.tip || `${d[opt.label]} — ${d[opt.val].toFixed(2)} ч`).replace(/"/g,'&quot;'));
    rect.addEventListener('mousemove', onTipMove);
    rect.addEventListener('mouseenter', onTipShow);
    rect.addEventListener('mouseleave', onTipHide);
    svg.appendChild(rect);

    // подпись внизу (категория), переносы вручную
    const wrap = wrapLabel(d[opt.cat] || d[opt.label], 14);
    wrap.forEach((ln, k)=>{
      const text = document.createElementNS(NS, 'text');
      text.setAttribute('x', x + bw/2);
      text.setAttribute('y', h - 6 + (k*12));
      text.setAttribute('text-anchor','middle');
      text.setAttribute('font-size','10');
      text.setAttribute('fill','#374151');
      text.textContent = ln;
      svg.appendChild(text);
    });

    // значение — внутри вершины, белый «квадратик», с отступом от оси
    if (barH > 10){
      const val = d[opt.val];
      const lbl = document.createElementNS(NS,'text');
      lbl.setAttribute('x', x + bw/2);
      // минимальный отступ от оси X (низ) — 4px
      const labelY = Math.min(y + 14, (h-24)); // чтобы не заезжало на ось
      lbl.setAttribute('y', labelY);
      lbl.setAttribute('text-anchor','middle');
      lbl.setAttribute('font-size','11');
      lbl.setAttribute('fill','#111');
      lbl.setAttribute('class','bar-label');
      lbl.textContent = val.toFixed(2);
      svg.appendChild(lbl);
    } else {
      // очень маленькие — немного наложим
      const val = d[opt.val];
      const lbl = document.createElementNS(NS,'text');
      lbl.setAttribute('x', x + bw/2);
      const labelY = (h-32); // чуть выше оси
      lbl.setAttribute('y', labelY);
      lbl.setAttribute('text-anchor','middle');
      lbl.setAttribute('font-size','11');
      lbl.setAttribute('fill','#111');
      lbl.setAttribute('class','bar-label');
      lbl.textContent = val.toFixed(2);
      svg.appendChild(lbl);
    }
  });
}
function wrapLabel(s, width){
  s = String(s||'(не задано)');
  const words = s.split(/\s+/);
  const lines = [];
  let cur='';
  for (const w of words){
    if ((cur + ' ' + w).trim().length > width){
      if (cur) lines.push(cur);
      cur = w;
    } else {
      cur = (cur?cur+' ':'') + w;
    }
  }
  if (cur) lines.push(cur);
  return lines.slice(0,3); // ограничим до 3 строк
}
function onTipShow(e){ el.tip.style.visibility='visible'; el.tip.textContent = e.target.getAttribute('data-tip')||''; }
function onTipHide(){ el.tip.style.visibility='hidden'; }
function onTipMove(e){
  const pad=8;
  el.tip.style.left = (e.clientX + pad) + 'px';
  el.tip.style.top  = (e.clientY + pad) + 'px';
}

function renderCharts(){
  const data = S.filtered;
  if (!data.length){ el.dash.style.display='none'; return; }
  el.dash.style.display = '';

  const t = aq.from(data);

  const proj = t.groupby('projectDisp').rollup({h:d=>aq.op.sum(d.hours)}).orderby(aq.desc('h')).objects().slice(0,10);
  drawBars(el.svgProj, proj.map(o=>({label:o.projectDisp, cat:o.projectDisp, value:o.h, tip:`${o.projectDisp}: ${o.h.toFixed(2)} ч`})), {label:'label', cat:'cat', val:'value', color:'#2563eb'});

  const pers = t.groupby('personDisp').rollup({h:d=>aq.op.sum(d.hours)}).orderby(aq.desc('h')).objects().slice(0,10);
  drawBars(el.svgPers, pers.map(o=>({label:o.personDisp, cat:o.personDisp, value:o.h, tip:`${o.personDisp}: ${o.h.toFixed(2)} ч`})), {label:'label', cat:'cat', val:'value', color:'#059669'});

  const type = t.groupby('typeDisp').rollup({h:d=>aq.op.sum(d.hours)}).orderby(aq.desc('h')).objects().slice(0,10);
  drawBars(el.svgType, type.map(o=>({label:o.typeDisp, cat:o.typeDisp, value:o.h, tip:`${o.typeDisp}: ${o.h.toFixed(2)} ч`})), {label:'label', cat:'cat', val:'value', color:'#7c3aed'});

  // daily
  const series = buildDailySeries(data);
  const daily = series.map(p=>({label:p.date, cat:p.date, value:p.h, tip:`${p.date}: ${p.h.toFixed(2)} ч`}));
  drawBars(el.svgDaily, daily, {label:'label', cat:'cat', val:'value', color:'#ef4444', w:1400, h:280, padX:80});
  // заголовки с контекстом
  const ctx = contextLabel();
  el.l1.textContent = ctx;
  el.l2.textContent = ctx;
  el.l3.textContent = ctx;
  el.l4.textContent = ctx;
}

/* ====== ПОЛНЫЙ АДАПТИВНЫЙ ОТЧЁТ (замена renderReport) ====== */
function renderReport(){
  const t = aq.from(S.filtered);
  const totalHours = (t.rollup({h:d=>aq.op.sum(d.hours)}).objects()[0]||{h:0}).h||0;
  const recs = S.filtered.length;
  const uniqs = {
    projects: uniq(S.filtered.map(r=>r.projectDisp)).filter(Boolean),
    people:   uniq(S.filtered.map(r=>r.personDisp)).filter(Boolean),
    types:    uniq(S.filtered.map(r=>r.typeDisp)).filter(Boolean),
    days:     uniq(S.filtered.map(r=>r.date)).filter(d=>d && d!=="(нет даты)")
  };
  const pk = el.project.value, tk = el.type.value, sk = el.person.value;
  const only = { person: sk!=='*' && pk==='*' && tk==='*',
                 project: pk!=='*' && sk==='*' && tk==='*',
                 type: tk!=='*' && pk==='*' && sk==='*' };
  const comboCount = (pk!=='*') + (tk!=='*') + (sk!=='*');
  const ctx = contextLabel();

  const lines = [];
  // 0) Заголовок
  lines.push(`ОТЧЁТ ПО ТЕКУЩЕЙ ВЫБОРКЕ${ctx ? ` — ${ctx}` : ""}`);
  lines.push(``);

  // 1) Краткая выжимка
  const byDayFull = buildDailySeries(S.filtered);
  const peak = byDayFull.length ? [...byDayFull].sort((a,b)=>b.h-a.h)[0] : null;
  const avgPerDay = byDayFull.length ? (totalHours/byDayFull.length) : 0;
  const trend = linearTrend(byDayFull);
  const trendTxt = trend.ok ? (trend.change>0.05 ? `рост (${(trend.change*100).toFixed(1)}%)`
                       : (trend.change<-0.05 ? `снижение (${(trend.change*100).toFixed(1)}%)` : `без выраженного тренда`))
                       : `недостаточно точек для тренда`;
  lines.push(`За период отработано ${totalHours.toFixed(2)} ч по ${uniqs.projects.length} проекта(м), ${uniqs.people.length} исполнител(ям), ${uniqs.types.length} виду(ам) работ.`);
  if (peak) lines.push(`Пиковый день: ${peak.date} — ${peak.h.toFixed(2)} ч; среднее по дню: ${avgPerDay.toFixed(2)} ч; тренд: ${trendTxt}.`);
  lines.push(``);

  // 2) СВОДНЫЕ
  lines.push(`СВОДНЫЕ ПОКАЗАТЕЛИ`);
  lines.push(`• Всего записей: ${recs}`);
  lines.push(`• Дней с данными: ${uniqs.days.length}`);
  lines.push(`• Разнообразие: проекты=${uniqs.projects.length} · исполнители=${uniqs.people.length} · виды=${uniqs.types.length}`);
  lines.push(``);

  // 3) Фокусы/Комбинации
  if (only.project){
    const projName = labelByKey('project', pk);
    const byPers = t.groupby("personDisp").rollup({h:d=>aq.op.sum(d.hours)}).orderby(aq.desc("h")).objects();
    const byType = t.groupby("typeDisp").rollup({h:d=>aq.op.sum(d.hours)}).orderby(aq.desc("h")).objects();
    lines.push(`ФОКУС: ПРОЕКТ — ${projName}`);
    lines.push(`• Итого часов по проекту: ${totalHours.toFixed(2)}`);
    lines.push(`• Топ исполнителей:`); lines.push(listBlock(byPers.slice(0,10), totalHours));
    lines.push(`• Структура по видам работ:`); lines.push(listBlock(byType.slice(0,10), totalHours));
    lines.push(``);
  } else if (only.person){
    const personName = labelByKey('person', sk);
    const byProj = t.groupby("projectDisp").rollup({h:d=>aq.op.sum(d.hours)}).orderby(aq.desc("h")).objects();
    const byType = t.groupby("typeDisp").rollup({h:d=>aq.op.sum(d.hours)}).orderby(aq.desc("h")).objects();
    lines.push(`ФОКУС: ИСПОЛНИТЕЛЬ — ${personName}`);
    lines.push(`• Итого часов: ${totalHours.toFixed(2)}`);
    lines.push(`• Распределение по проектам:`); lines.push(listBlock(byProj.slice(0,10), totalHours));
    lines.push(`• Распределение по видам работ:`); lines.push(listBlock(byType.slice(0,10), totalHours));
    lines.push(``);
  } else if (only.type){
    const typeName = labelByKey('type', tk);
    const byProj = t.groupby("projectDisp").rollup({h:d=>aq.op.sum(d.hours)}).orderby(aq.desc("h")).objects();
    const byPers = t.groupby("personDisp").rollup({h:d=>aq.op.sum(d.hours)}).orderby(aq.desc("h")).objects();
    lines.push(`ФОКУС: ВИД РАБОТ — ${typeName}`);
    lines.push(`• Итого часов: ${totalHours.toFixed(2)}`);
    lines.push(`• Проекты:`); lines.push(listBlock(byProj.slice(0,10), totalHours));
    lines.push(`• Исполнители:`); lines.push(listBlock(byPers.slice(0,10), totalHours));
    lines.push(``);
  } else if (comboCount===2){
    if (pk!=='*' && sk!=='*'){
      const projName = labelByKey('project', pk);
      const personName = labelByKey('person', sk);
      const sum = (t.rollup({h:d=>aq.op.sum(d.hours)}).objects()[0]||{h:0}).h||0;
      const byType = t.groupby("typeDisp").rollup({h:d=>aq.op.sum(d.hours)}).orderby(aq.desc("h")).objects();
      lines.push(`ФОКУС: ПРОЕКТ × ИСПОЛНИТЕЛЬ — ${projName} × ${personName}`);
      lines.push(`• Итого часов по сочетанию: ${sum.toFixed(2)}`);
      lines.push(`• Виды работ:`); lines.push(listBlock(byType.slice(0,10), sum||1));
      lines.push(``);
    }
    if (pk!=='*' && tk!=='*' && sk==='*'){
      const projName = labelByKey('project', pk);
      const typeName = labelByKey('type', tk);
      const byPers = t.groupby("personDisp").rollup({h:d=>aq.op.sum(d.hours)}).orderby(aq.desc("h")).objects();
      lines.push(`ФОКУС: ПРОЕКТ × ВИД — ${projName} × ${typeName}`);
      lines.push(`• Исполнители:`); lines.push(listBlock(byPers.slice(0,10), totalHours));
      lines.push(``);
    }
    if (tk!=='*' && sk!=='*' && pk==='*'){
      const typeName = labelByKey('type', tk);
      const personName = labelByKey('person', sk);
      const byProj = t.groupby("projectDisp").rollup({h:d=>aq.op.sum(d.hours)}).orderby(aq.desc("h")).objects();
      lines.push(`ФОКУС: ВИД × ИСПОЛНИТЕЛЬ — ${typeName} × ${personName}`);
      lines.push(`• Проекты:`); lines.push(listBlock(byProj.slice(0,10), totalHours));
      lines.push(``);
    }
  } else if (comboCount===3){
    const projName = labelByKey('project', pk);
    const typeName = labelByKey('type', tk);
    const personName = labelByKey('person', sk);
    lines.push(`УЗКИЙ ФОКУС: ${projName} × ${typeName} × ${personName}`);
    lines.push(`• Итого часов по сочетанию: ${totalHours.toFixed(2)}`);
    lines.push(``);
  }

  // 4) Топ-списки
  const projTop = t.groupby("projectDisp").rollup({h:d=>aq.op.sum(d.hours)}).orderby(aq.desc("h")).objects().slice(0,10);
  const peopTop = t.groupby("personDisp").rollup({h:d=>aq.op.sum(d.hours)}).orderby(aq.desc("h")).objects().slice(0,10);
  const typeTop = t.groupby("typeDisp").rollup({h:d=>aq.op.sum(d.hours)}).orderby(aq.desc("h")).objects().slice(0,10);
  lines.push(`TOP-10 ПРОЕКТОВ`);
  lines.push(listBlock(projTop, totalHours));
  lines.push(``);
  lines.push(`TOP-10 ИСПОЛНИТЕЛЕЙ`);
  lines.push(listBlock(peopTop, totalHours));
  lines.push(``);
  lines.push(`TOP-10 ВИДОВ РАБОТ`);
  lines.push(listBlock(typeTop, totalHours));
  lines.push(``);

  // 5) Динамика
  if (byDayFull.length>=8){
    const peak2 = [...byDayFull].sort((a,b)=>b.h-a.h)[0];
    const min2  = [...byDayFull].filter(p=>p.h>0).sort((a,b)=>a.h-b.h)[0] || null;
    const sumSeries = byDayFull.reduce((acc,p)=>acc+p.h,0);
    const avg2 = sumSeries/byDayFull.length;
    lines.push(`ДИНАМИКА ПО ДНЯМ`);
    lines.push(`• Точек: ${byDayFull.length} · Среднее: ${avg2.toFixed(2)} ч/день · Пик: ${peak2.date} — ${peak2.h.toFixed(2)} ч`);
    if (min2) lines.push(`• Минимум (ненулевой): ${min2.date} — ${min2.h.toFixed(2)} ч`);
    lines.push(`• Тренд: ${trendTxt}`);
    lines.push(``);
  } else {
    lines.push(`ДИНАМИКА ПО ДНЯМ`);
    lines.push(`• Недостаточно точек для тренда (минимум 8).`);
    lines.push(``);
  }

  // 6) Дополнительно — аномалии, тихие зоны, дисбаланс, качество данных
  const anomalies = detectAnomalies(byDayFull, 7, 1.5, 1.3);
  if (anomalies.length){
    lines.push(`АНОМАЛИИ / ПЕРЕРАБОТКИ`);
    lines.push(`• Дни с превышением порога:`);
    anomalies.slice(0,10).forEach(a=>{
      lines.push(`  - ${a.date}: ${a.h.toFixed(2)} ч (порог ~ ${(Math.max(a.mu*1.3, a.mu+1.5*a.sd)).toFixed(2)} ч)`);
    });
    if (anomalies.length>10) lines.push(`  … и ещё ${anomalies.length-10}`);
    lines.push(``);
  }

  const quiet = detectQuietZones(byDayFull, 3);
  if (quiet.length){
    lines.push(`ТИХИЕ ЗОНЫ / НЕДОЗАГРУЗКА`);
    quiet.slice(0,10).forEach(z=>{
      lines.push(`• ${z.from} — ${z.to} (${z.len} дн.)`);
    });
    if (quiet.length>10) lines.push(`… и ещё ${quiet.length-10}`);
    lines.push(``);
  }

  const imbProj = imbalanceInfo(projTop.map(o=>({h:o.h, label:o.projectDisp})), 3, 0.60);
  if (imbProj.trigger){
    lines.push(`ДИСБАЛАНС / КОНЦЕНТРАЦИЯ`);
    lines.push(`• Доля топ-3 проектов: ${(imbProj.share*100).toFixed(1)}%`);
    lines.push(`• Топ-3:`);
    imbProj.top.forEach((r,i)=>lines.push(`  ${i+1}) ${r.label}: ${r.h.toFixed(2)} ч`));
    lines.push(``);
  }

  const dq = (function(){
    let noDate=0, zeroH=0, negH=0, emptyProj=0, emptyType=0, emptyPerson=0;
    for (const r of S.filtered){
      if (!r.date || r.date==="(нет даты)") noDate++;
      if (!Number.isFinite(r.hours) || r.hours===0) zeroH++;
      if (Number.isFinite(r.hours) && r.hours<0) negH++;
      if (!r.projectDisp || r.projectDisp==="(не задано)") emptyProj++;
      if (!r.typeDisp || r.typeDisp==="(не задано)") emptyType++;
      if (!r.personDisp || r.personDisp==="(не задано)") emptyPerson++;
    }
    return {noDate, zeroH, negH, emptyProj, emptyType, emptyPerson};
  })();
  if (dq.noDate || dq.zeroH || dq.negH || dq.emptyProj || dq.emptyType || dq.emptyPerson){
    lines.push(`КАЧЕСТВО ДАННЫХ`);
    if (dq.noDate)     lines.push(`• Без даты: ${dq.noDate} записей`);
    if (dq.zeroH)      lines.push(`• Нулевые часы: ${dq.zeroH} записей`);
    if (dq.negH)       lines.push(`• Отрицательные часы: ${dq.negH} записей`);
    if (dq.emptyProj)  lines.push(`• Пустой проект: ${dq.emptyProj} записей`);
    if (dq.emptyType)  lines.push(`• Пустой вид работ: ${dq.emptyType} записей`);
    if (dq.emptyPerson)lines.push(`• Пустой исполнитель: ${dq.emptyPerson} записей`);
    lines.push(``);
  }

  // 7) Примечания
  lines.push(`ПРИМЕЧАНИЯ`);
  lines.push(`• Все значения рассчитаны по текущим фильтрам и периоду.`);
  lines.push(`• Пороги: аномалии — >130% скользящего среднего (окно 7 дней) или >1.5σ; тихие зоны — ≥3 подряд дней с 0 ч; дисбаланс — доля топ-3 проектов ≥60%.`);

  el.reportText.textContent = lines.join("\n");
}

/* ========= ДЕЙСТВИЯ ========= */
el.apply.addEventListener('click', ()=> applyFilters());
el.reset.addEventListener('click', ()=>{
  if (!S.raw.length) return;
  el.project.value='*'; el.type.value='*'; el.person.value='*';
  // восстановим даты
  const dates = S.raw.map(r=>r.date).filter(x=>x && x!=='(нет даты)');
  if (dates.length){
    const min = dates.slice().sort()[0];
    const max = dates.slice().sort().reverse()[0];
    el.from.value = min; el.to.value = max;
  } else { el.from.value=''; el.to.value=''; }
  applyFilters();
});
el.clear.addEventListener('click', ()=>{
  S.raw=[]; S.filtered=[]; S.wb=null; S.sheets=[];
  el.file.value=''; el.sheet.innerHTML='';
  el.from.value=''; el.to.value='';
  el.project.innerHTML=''; el.type.innerHTML=''; el.person.innerHTML='';
  renderAll();
});

// экспорт отчёта
el.copy.addEventListener('click', async ()=>{
  const txt = el.reportText.textContent || '';
  try{ await navigator.clipboard.writeText(txt); }catch(_){}
});
el.txt.addEventListener('click', ()=>{
  const blob = new Blob([el.reportText.textContent||''], {type:'text/plain;charset=utf-8'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'report.txt';
  document.body.appendChild(a); a.click(); a.remove();
});
</script>
</body>
</html>
